/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Cell.js":
/*!*********************!*\
  !*** ./src/Cell.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Cell)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nvar Cell = /*#__PURE__*/function () {\n  function Cell(value, className) {\n    _classCallCheck(this, Cell);\n\n    this.value = value;\n    this.frozenValue = value + 10;\n    this.className = className;\n  }\n\n  _createClass(Cell, [{\n    key: \"getValue\",\n    value: function getValue() {\n      return this.value;\n    }\n  }, {\n    key: \"getFrozenValue\",\n    value: function getFrozenValue() {\n      return this.frozenValue;\n    }\n  }, {\n    key: \"getClassName\",\n    value: function getClassName() {\n      return this.className;\n    }\n  }, {\n    key: \"getHtmlTag\",\n    value: function getHtmlTag() {\n      return \"<div class='cell \".concat(this.className, \"'></div>\");\n    }\n  }]);\n\n  return Cell;\n}();\n\n\n\n//# sourceURL=webpack://babel_weback_starter/./src/Cell.js?");

/***/ }),

/***/ "./src/tetris_script.js":
/*!******************************!*\
  !*** ./src/tetris_script.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Cell__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Cell */ \"./src/Cell.js\");\n\nvar world = [[0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];\nvar ruins = [[0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0]];\nvar WORLD = 'world';\nvar RUINS = 'ruins';\nvar emptyCell = new _Cell__WEBPACK_IMPORTED_MODULE_0__[\"default\"](0, 'empty');\nvar barShapeCell = new _Cell__WEBPACK_IMPORTED_MODULE_0__[\"default\"](1, 'barShape');\nvar lShapeCell = new _Cell__WEBPACK_IMPORTED_MODULE_0__[\"default\"](2, 'lShape');\nvar zShapeCell = new _Cell__WEBPACK_IMPORTED_MODULE_0__[\"default\"](3, 'zShape');\nvar squareShapeCell = new _Cell__WEBPACK_IMPORTED_MODULE_0__[\"default\"](4, 'squareShape');\nvar reverseZshapeCell = new _Cell__WEBPACK_IMPORTED_MODULE_0__[\"default\"](5, 'reverseZshape');\nvar pyramidCell = new _Cell__WEBPACK_IMPORTED_MODULE_0__[\"default\"](6, 'pyramid');\nvar reverseLshapeCell = new _Cell__WEBPACK_IMPORTED_MODULE_0__[\"default\"](7, 'reverseLshape');\n\nfunction isOfType(worldSpot, cell) {\n  return worldSpot === cell.getValue() || worldSpot === cell.getFrozenValue();\n}\n\nfunction drawWorld() {\n  document.getElementById(WORLD).innerHTML = \"\";\n\n  for (var y = 0; y < world.length; y++) {\n    for (var x = 0; x < world[y].length; x++) {\n      if (isOfType(world[y][x], emptyCell)) {\n        document.getElementById(WORLD).innerHTML += emptyCell.getHtmlTag();\n      } else if (isOfType(world[y][x], barShapeCell)) {\n        document.getElementById(WORLD).innerHTML += barShapeCell.getHtmlTag();\n      } else if (isOfType(world[y][x], lShapeCell)) {\n        document.getElementById(WORLD).innerHTML += lShapeCell.getHtmlTag();\n      } else if (isOfType(world[y][x], zShapeCell)) {\n        document.getElementById(WORLD).innerHTML += zShapeCell.getHtmlTag();\n      } else if (isOfType(world[y][x], squareShapeCell)) {\n        document.getElementById(WORLD).innerHTML += squareShapeCell.getHtmlTag();\n      } else if (isOfType(world[y][x], reverseZshapeCell)) {\n        document.getElementById(WORLD).innerHTML += reverseZshapeCell.getHtmlTag();\n      } else if (isOfType(world[y][x], pyramidCell)) {\n        document.getElementById(WORLD).innerHTML += pyramidCell.getHtmlTag();\n      } else if (isOfType(world[y][x], reverseLshapeCell)) {\n        document.getElementById(WORLD).innerHTML += reverseLshapeCell.getHtmlTag();\n      }\n    }\n\n    document.getElementById(WORLD).innerHTML += \"<br>\";\n  }\n}\n\nfunction drawRuins() {\n  document.getElementById(RUINS).innerHTML = \"\";\n\n  for (var y = 0; y < ruins.length; y++) {\n    for (var x = 0; x < ruins[y].length; x++) {\n      if (ruins[y][x] === emptyCell.getValue()) {\n        document.getElementById(RUINS).innerHTML += \"<div class='cell'></div>\";\n      } else if (ruins[y][x] === barShapeCell.getValue()) {\n        document.getElementById(RUINS).innerHTML += barShapeCell.getHtmlTag();\n      } else if (ruins[y][x] === lShapeCell.getValue()) {\n        document.getElementById(RUINS).innerHTML += lShapeCell.getHtmlTag();\n      } else if (ruins[y][x] === zShapeCell.getValue()) {\n        document.getElementById(RUINS).innerHTML += zShapeCell.getHtmlTag();\n      } else if (ruins[y][x] === squareShapeCell.getValue()) {\n        document.getElementById(RUINS).innerHTML += squareShapeCell.getHtmlTag();\n      } else if (ruins[y][x] === reverseZshapeCell.getValue()) {\n        document.getElementById(RUINS).innerHTML += reverseZshapeCell.getHtmlTag();\n      } else if (ruins[y][x] === pyramidCell.getValue()) {\n        document.getElementById(RUINS).innerHTML += pyramidCell.getHtmlTag();\n      } else if (world[y][x] === reverseLshapeCell.getValue()) {\n        document.getElementById(RUINS).innerHTML += reverseLshapeCell.getHtmlTag();\n      }\n    }\n\n    document.getElementById(RUINS).innerHTML += \"<br>\";\n  }\n}\n\nfunction moveShapesDown() {\n  var canMove = true;\n\n  for (var y = world.length - 1; y >= 0; y--) {\n    for (var x = 0; x < world[y].length; x++) {\n      if (world[y][x] > 0 && world[y][x] < 10) {\n        if (y + 1 === world.length || world[y + 1][x] > 10) {\n          canMove = false;\n          freeze();\n        }\n      }\n    }\n  }\n\n  if (canMove) {\n    for (var y = world.length - 1; y >= 0; y--) {\n      for (var x = 0; x < world[y].length; x++) {\n        if (world[y][x] > 0 && world[y][x] < 10) {\n          world[y + 1][x] = world[y][x];\n          world[y][x] = 0;\n        }\n      }\n    }\n\n    drawWorld();\n  }\n\n  checkLines();\n}\n\nfunction moveShapesLeft() {\n  var canMove = true;\n\n  for (var y = world.length - 1; y >= 0; y--) {\n    for (var x = 0; x < world[y].length; x++) {\n      if (world[y][x] > 0 && world[y][x] < 10) {\n        if (x === 0 || world[y][x - 1] > 10) {\n          canMove = false;\n        }\n      }\n    }\n  }\n\n  if (canMove) {\n    for (var y = world.length - 1; y >= 0; y--) {\n      for (var x = 0; x < world[y].length; x++) {\n        if (world[y][x] > 0 && world[y][x] < 10) {\n          world[y][x - 1] = world[y][x];\n          world[y][x] = 0;\n        }\n      }\n    }\n\n    drawWorld();\n  }\n}\n\nfunction moveShapesRight() {\n  var canMove = true;\n\n  for (var y = world.length - 1; y >= 0; y--) {\n    for (var x = 0; x < world[y].length; x++) {\n      if (world[y][x] > 0 && world[y][x] < 10) {\n        if (x === 9 || world[y][x + 1] > 10) {\n          canMove = false;\n        }\n      }\n    }\n  }\n\n  if (canMove) {\n    for (var y = world.length - 1; y >= 0; y--) {\n      for (var x = world[y].length; x >= 0; x--) {\n        if (world[y][x] > 0 && world[y][x] < 10) {\n          world[y][x + 1] = world[y][x];\n          world[y][x] = 0;\n        }\n      }\n    }\n\n    drawWorld();\n  }\n}\n\nfunction rotateShapeRight() {\n  var canMove = true;\n\n  for (var y = world.length - 1; y >= 0; y--) {\n    for (var x = 0; x < world[y].length; x++) {\n      if (world[y][x] > 0 && world[y][x] < 10) {\n        if (world[y + 1][x] > 10 || world[y - 1][x] > 10) {\n          canMove = false;\n        }\n      }\n    }\n  }\n\n  if (canMove) {\n    var turn = 0; //the variable \"turn\" allows the function to work only once when the first cell of the shape is met by the loop AND not for EVERY cell of the shape\n\n    for (var y = world.length - 1; y >= 0; y--) {\n      for (var x = 0; x < world[y].length; x++) {\n        if (world[y][x] > 0 && world[y][x] < 10) {\n          if (world[y][x] === 1 && turn === 0) {\n            if (world[y - 1][x] === 1) {\n              //The barShape (value=1) is VERTICAL\n              if (count % 3 === 0) {\n                //My shape will rotate on the second cell of my shape (from the top)\n                if (world[y - 2][x + 1] != 0 && world[y - 2][x - 1] === 0 && world[y - 2][x - 2] === 0 && world[y - 2][x - 3] === 0) {\n                  //If my shape is blocked on the right side but free on the left side\n                  world[y - 2][x - 1] = world[y][x];\n                  world[y - 2][x - 2] = world[y - 1][x];\n                  world[y - 2][x - 3] = world[y - 3][x]; //I reset to 0 the cases that should now be empty\n\n                  world[y][x] = 0;\n                  world[y - 1][x] = 0;\n                  world[y - 3][x] = 0;\n                } else if (world[y - 2][x - 1] != 0 && world[y - 2][x + 1] === 0 && world[y - 2][x + 2] === 0 && world[y - 2][x + 3] === 0) {\n                  //If my shape is blocked on the left side (no space on the left) but free on the right side\n                  world[y - 2][x + 1] = world[y][x];\n                  world[y - 2][x + 2] = world[y - 1][x];\n                  world[y - 2][x + 3] = world[y - 3][x]; //I reset to 0 the cases that should now be empty\n\n                  world[y][x] = 0;\n                  world[y - 1][x] = 0;\n                  world[y - 3][x] = 0;\n                } else if (world[y - 2][x - 1] === 0 && world[y - 2][x - 2] === 0 && world[y - 2][x + 1] === 0) {\n                  //If the shape can move freely\n                  world[y - 2][x - 1] = world[y - 3][x];\n                  world[y - 2][x + 1] = world[y - 1][x];\n                  world[y - 2][x - 2] = world[y][x]; //I reset to 0 the cases that should now be empty\n\n                  world[y - 3][x] = 0;\n                  world[y - 1][x] = 0;\n                  world[y][x] = 0;\n                }\n              } else if (count % 3 !== 0) {\n                //My shape will rotate on the third cell of my shape (from the top)\n                if (world[y - 1][x - 1] != 0 && world[y - 1][x + 1] === 0 && world[y - 1][x + 2] === 0 && world[y - 1][x + 3] === 0) {\n                  //If my shape is blocked on the left side but free on the right side\n                  world[y - 1][x + 1] = world[y][x];\n                  world[y - 1][x + 2] = world[y - 2][x];\n                  world[y - 1][x + 3] = world[y - 3][x]; //I reset to 0 the cases that should now be empty\n\n                  world[y][x] = 0;\n                  world[y - 2][x] = 0;\n                  world[y - 3][x] = 0;\n                } else if (world[y - 1][x + 1] != 0 && world[y - 1][x - 1] === 0 && world[y - 1][x - 2] === 0 && world[y - 1][x - 3] === 0) {\n                  //If my shape is blocked on the right side but free on the left side\n                  world[y - 1][x - 1] = world[y][x];\n                  world[y - 1][x - 2] = world[y - 2][x];\n                  world[y - 1][x - 3] = world[y - 3][x]; //I reset to 0 the cases that should now be empty\n\n                  world[y][x] = 0;\n                  world[y - 2][x] = 0;\n                  world[y - 3][x] = 0;\n                } else if (world[y - 1][x - 1] === 0 && world[y - 1][x + 1] === 0 && world[y - 1][x + 2] === 0) {\n                  //my shape is free to move\n                  world[y - 1][x - 1] = world[y - 2][x];\n                  world[y - 1][x + 1] = world[y][x];\n                  world[y - 1][x + 2] = world[y - 3][x]; //I reset to 0 the cases that should now be empty\n\n                  world[y - 3][x] = 0;\n                  world[y - 2][x] = 0;\n                  world[y][x] = 0;\n                }\n              }\n            } else if (world[y - 1][x] === 0) {\n              //The barShape (value=1) is HORIZONTAL\n              if (count % 3 === 0) {\n                world[y - 1][x + 1] = world[y][x];\n                world[y + 1][x + 1] = world[y][x + 2];\n                world[y + 2][x + 1] = world[y][x + 3]; //I reset to 0 the cases that should now be empty\n\n                world[y][x] = 0;\n                world[y][x + 2] = 0;\n                world[y][x + 3] = 0;\n              } else if (count % 3 !== 0) {\n                world[y - 1][x + 2] = world[y][x + 1];\n                world[y - 2][x + 2] = world[y][x];\n                world[y + 1][x + 2] = world[y][x + 3]; //I reset to 0 the cases that should now be empty\n\n                world[y][x + 1] = 0;\n                world[y][x + 3] = 0;\n                world[y][x] = 0;\n              }\n            }\n          } else if (world[y][x] === 2 && turn === 0) {\n            //value 2 = L shape\n            if (world[y][x + 1] === 2 && world[y - 1][x] === 2 && world[y - 2][x] === 2) {\n              //The shape points to the top and will rotate clockwise\n              if (world[y][x + 2] !== 0 && world[y + 1][x - 1] === 0) {\n                //If the shape is blocked on the right side\n                world[y][x - 1] = world[y - 1][x];\n                world[y + 1][x - 1] = world[y - 2][x]; //I reset to 0 the cases that should now be empty\n\n                world[y - 1][x] = 0;\n                world[y - 2][x] = 0;\n              } else {\n                //If the shape can move freely\n                world[y + 1][x] = world[y][x + 1];\n                world[y][x + 2] = world[y - 2][x]; //I reset to 0 the cases that should now be empty\n\n                world[y - 1][x] = 0;\n                world[y - 2][x] = 0;\n              }\n            } else if (world[y - 1][x] === 2 && world[y - 1][x + 1] === 2 && world[y - 1][x + 2] === 2) {\n              //The shape points right and will rotate clockwise\n              if (world[y - 1][x - 1] !== 0 && world[y + 1][x] === 0) {\n                //The shape is blocked on the left side\n                world[y][x + 1] = world[y][x];\n                world[y + 1][x + 1] = world[y - 1][x + 2]; //I reset to 0 the cases that should now be empty\n\n                world[y][x] = 0;\n                world[y - 1][x + 2] = 0;\n              } else if (world[y - 1][x - 1] === 0 && world[y + 1][x] === 0) {\n                //The shape can move freely\n                world[y - 1][x - 1] = world[y][x];\n                world[y + 1][x] = world[y - 1][x + 1]; //I reset to 0 the cases that should now be empty\n\n                world[y - 1][x + 1] = 0;\n                world[y - 1][x + 2] = 0;\n              }\n            } else if (world[y - 1][x] === 2 && world[y - 2][x] === 2 && world[y - 2][x - 1] === 2) {\n              //The shape points to the bottom and will rotate clockwise\n              if (world[y - 2][x - 2] !== 0) {\n                world[y - 2][x + 1] = world[y][x];\n                world[y - 3][x + 1] = world[y - 1][x]; //I reset to 0 the cases that should now be empty\n\n                world[y][x] = 0;\n                world[y - 1][x] = 0;\n              } else if (world[y - 2][x - 2] === 0) {\n                world[y - 2][x - 2] = world[y][x];\n                world[y - 3][x] = world[y - 1][x]; //I reset to 0 the cases that should now be empty\n\n                world[y][x] = 0;\n                world[y - 1][x] = 0;\n              }\n            } else if (world[y][x + 1] === 2 && world[y][x + 2] === 2 && world[y - 1][x + 2] === 2) {\n              //the shape points left and will rotate clockwise\n              world[y][x + 3] = world[y - 1][x + 2];\n              world[y - 2][x + 2] = world[y][x + 2]; //I reset to 0 the cases that should now be empty\n\n              world[y][x] = 0;\n              world[y][x + 1] = 0;\n            }\n          } else if (world[y][x] === 3 && turn === 0) {\n            // value 3 = Z shape\n            if (world[y][x + 1] === 3 && world[y - 1][x] === 3 && world[y - 1][x - 1] === 3) {\n              //The shape looks like a Z and will rotate clockwise\n              world[y + 1][x] = world[y - 1][x - 1];\n              world[y - 1][x + 1] = world[y - 1][x]; //I reset to 0 the cases that should now be empty\n\n              world[y - 1][x - 1] = 0;\n              world[y - 1][x] = 0;\n            } else if (world[y - 1][x] === 3 && world[y - 1][x + 1] === 3 && world[y - 2][x + 1] === 3) {\n              //The shape looks like a N and will rotate clockwise\n              if (world[y - 1][x - 1] === 0 && world[y][x + 1] === 0) {\n                //If my shape can move freely\n                world[y - 1][x - 1] = world[y - 1][x + 1];\n                world[y][x + 1] = world[y - 2][x + 1]; //I reset to 0 the cases that should now be empty\n\n                world[y - 1][x + 1] = 0;\n                world[y - 2][x + 1] = 0;\n              } else if (world[y - 1][x - 1] !== 0 && world[y][x + 1] === 0 && world[y][x + 2] === 0) {\n                //If my shape is blocked on the left side but is free on the right side\n                world[y][x + 1] = world[y][x];\n                world[y][x + 2] = world[y - 2][x + 1]; //I reset to 0\n\n                world[y][x] = 0;\n                world[y - 2][x + 1] = 0;\n              }\n            }\n          } else if (world[y][x] === 5 && turn === 0) {\n            //value 5 = S shape\n            if (world[y][x + 1] === 5 && world[y - 1][x + 1] === 5 && world[y - 1][x + 2] === 5) {\n              //The shape looks like a S\n              if (world[y + 1][x + 1] === 0 && world[y - 1][x] === 0) {\n                world[y + 1][x + 1] = world[y - 1][x + 2];\n                world[y - 1][x] = world[y - 1][x + 1]; //I reset to 0\n\n                world[y - 1][x + 2] = 0;\n                world[y - 1][x + 1] = 0;\n              } else if (world[y + 1][x + 1] !== 0 && world[y - 1][x] === 0) {\n                world[y - 2][x] = world[y - 1][x + 2];\n                world[y - 1][x] = world[y][x]; //I reset to 0 the cases that should now be empty\n\n                world[y - 1][x + 2] = 0;\n                world[y][x] = 0;\n              }\n            } else if (world[y - 1][x] === 5 && world[y - 1][x - 1] === 5 && world[y - 2][x - 1] === 5) {\n              // The shape looks like a reverse N\n              if (world[y - 1][x + 1] === 0 && world[y][x - 1] === 0) {\n                //If my shape can move freely\n                world[y - 1][x + 1] = world[y - 2][x - 1];\n                world[y][x - 1] = world[y - 1][x - 1]; //I reset to 0 the cases that should now be empty\n\n                world[y - 2][x - 1] = 0;\n                world[y - 1][x - 1] = 0;\n              } else if (world[y - 1][x + 1] !== 0 && world[y][x - 1] === 0 && world[y][x - 2] === 0) {\n                //If my shape is blocked on the right side but free on the left side\n                world[y][x - 1] = world[y][x];\n                world[y][x - 2] = world[y - 2][x - 1]; //I reset to 0\n\n                world[y][x] = 0;\n                world[y - 2][x - 1] = 0;\n              }\n            }\n          } else if (world[y][x] === 6 && turn === 0) {\n            //value 6 = pyramid\n            if (world[y][x + 1] === 6 && world[y][x + 2] === 6) {\n              //the pyramid points to the top and will rotate clock wise\n              if (world[y + 1][x + 1] === 0) {\n                //shape can move freely\n                world[y + 1][x + 1] = world[y][x]; //I reset to 0\n\n                world[y][x] = 0;\n              }\n            } else if (world[y - 1][x] === 6 && world[y - 2][x] === 6 && world[y - 1][x + 1] === 6) {\n              //the shape points right and will rotate clockwise\n              if (world[y - 1][x - 1] === 0) {\n                //can move freely\n                world[y - 1][x - 1] = world[y - 2][x]; //I reset to 0\n\n                world[y - 2][x] = 0;\n              } else if (world[y - 1][x - 1] !== 0) {\n                //shape blocked on the left side\n                world[y - 1][x + 2] = world[y][x];\n                world[y - 2][x + 1] = world[y - 2][x]; //I reset to 0;\n\n                world[y][x] = 0;\n                world[y - 2][x] = 0;\n              }\n            } else if (world[y - 1][x - 1] === 6 && world[y - 1][x] === 6 && world[y - 1][x + 1] === 6) {\n              //The shape points to the bottom and will rotate clockwise\n              if (world[y - 2][x] === 0) {\n                world[y - 2][x] = world[y - 1][x + 1]; //I reset\n\n                world[y - 1][x + 1] = 0;\n              }\n            } else if (world[y - 1][x - 1] === 6 && world[y - 1][x] === 6 && world[y - 2][x] === 6) {\n              //The shape points left\n              if (world[y - 1][x + 1] === 0) {\n                world[y - 1][x + 1] = world[y][x];\n                world[y][x] = 0;\n              } else if (world[y - 1][x + 1] !== 0) {\n                world[y - 1][x - 2] = world[y][x];\n                world[y - 2][x - 1] = world[y - 2][x]; //I reset\n\n                world[y][x] = 0;\n                world[y - 2][x] = 0;\n              }\n            }\n          } else if (world[y][x] === 7 && turn === 0) {\n            //value 7 = reverse L shape\n            if (world[y][x + 1] === 7 && world[y - 1][x + 1] === 7 && world[y - 2][x + 1] === 7) {\n              //The shape points to the top and will rotate clockwise\n              if (world[y][x + 2] !== 0 && world[y - 1][x] === 0 && world[y - 1][x - 1] === 0 && world[y - 2][x - 1] === 0) {\n                //If the shape is blocked on the right side\n                world[y - 1][x] = world[y][x];\n                world[y - 1][x - 1] = world[y][x + 1];\n                world[y - 2][x - 1] = world[y - 2][x + 1]; //I reset to 0 the cases that should now be empty\n\n                world[y][x] = 0;\n                world[y][x + 1] = 0;\n                world[y - 2][x + 1] = 0;\n              } else if (world[y - 1][x] === 0 && world[y - 2][x] === 0 && world[y - 1][x + 2] === 0) {\n                //If the shape can move freely\n                world[y - 1][x] = world[y][x];\n                world[y - 2][x] = world[y][x + 1];\n                world[y - 1][x + 2] = world[y - 2][x + 1]; //I reset to 0 the cases that should now be empty\n\n                world[y][x] = 0;\n                world[y][x + 1] = 0;\n                world[y - 2][x + 1] = 0;\n              }\n            } else if (world[y - 1][x] === 7 && world[y][x + 1] === 7 && world[y][x + 2] === 7) {\n              //The shape points right and will rotate clockwise\n              if (world[y + 1][x] === 0 && world[y + 2][x] === 0) {\n                //The shape can move freely\n                world[y + 1][x] = world[y - 1][x];\n                world[y + 2][x] = world[y][x + 2]; //I reset to 0 the cases that should now be empty\n\n                world[y - 1][x] = 0;\n                world[y][x + 2] = 0;\n              }\n            } else if (world[y - 1][x] === 7 && world[y - 2][x] === 7 && world[y - 2][x + 1] === 7) {\n              //The shape points to the bottom and will rotate clockwise\n              if (world[y - 1][x - 1] !== 0 && world[y - 1][x + 1] === 0 && world[y - 1][x + 2] === 0 && world[y][x + 2] === 0) {\n                //The shape is blocked on the left side\n                world[y - 1][x + 1] = world[y][x];\n                world[y - 1][x + 2] = world[y - 2][x];\n                world[y][x + 2] = world[y - 2][x + 1]; //I reset to 0 the cases that should now be empty\n\n                world[y][x] = 0;\n                world[y - 2][x] = 0;\n                world[y - 2][x + 1] = 0;\n              } else if (world[y - 1][x - 1] === 0 && world[y - 1][x + 1] === 0 && world[y][x + 1] === 0) {\n                //Shape can move freely\n                world[y - 1][x - 1] = world[y][x];\n                world[y - 1][x + 1] = world[y - 2][x];\n                world[y][x + 1] = world[y - 2][x + 1]; //I reset to 0 the cases that should now be empty\n\n                world[y][x] = 0;\n                world[y - 2][x] = 0;\n                world[y - 2][x + 1] = 0;\n              }\n            } else if (world[y - 1][x] === 7 && world[y - 1][x - 1] === 7 && world[y - 1][x - 2] === 7) {\n              //the shape points left and will rotate clockwise\n              if (world[y - 2][x] === 0 && world[y - 3][x] === 0) {\n                world[y - 2][x] = world[y][x];\n                world[y - 3][x] = world[y - 1][x - 2]; //I reset to 0 the cases that should now be empty\n\n                world[y][x] = 0;\n                world[y - 1][x - 2] = 0;\n              }\n            }\n          }\n\n          turn++;\n        }\n      }\n    }\n\n    drawWorld();\n  }\n}\n\nfunction freeze() {\n  for (var y = world.length - 1; y >= 0; y--) {\n    for (var x = 0; x < world[y].length; x++) {\n      if (world[y][x] > 0 && world[y][x] < 10) {\n        world[y][x] = world[y][x] + 10;\n      }\n    }\n  }\n\n  checkLines();\n  var ran = Math.floor(Math.random() * 7);\n\n  if (ran === 0 && world[0][5] === 0 && world[1][5] === 0 && world[2][5] === 0 && world[3][5] === 0) {\n    //bar shape\n    world[0][5] = 1;\n    world[1][5] = 1;\n    world[2][5] = 1;\n    world[3][5] = 1;\n  } else if (ran === 1 && world[0][4] === 0 && world[1][4] === 0 && world[2][4] === 0 && world[2][5] === 0) {\n    //L shape\n    world[0][4] = 2;\n    world[1][4] = 2;\n    world[2][4] = 2;\n    world[2][5] = 2;\n  } else if (ran === 2 && world[0][4] === 0 && world[0][5] === 0 && world[1][5] === 0 && world[1][6] === 0) {\n    //Z shape\n    world[0][4] = 3;\n    world[0][5] = 3;\n    world[1][5] = 3;\n    world[1][6] = 3;\n  } else if (ran === 3 && world[0][4] === 0 && world[0][5] === 0 && world[1][4] === 0 && world[1][5] === 0) {\n    //cube\n    world[0][4] = 4;\n    world[0][5] = 4;\n    world[1][4] = 4;\n    world[1][5] = 4;\n  } else if (ran === 4 && world[0][4] === 0 && world[0][5] === 0 && world[1][3] === 0 && world[1][4] == 0) {\n    //S shape\n    world[0][4] = 5;\n    world[0][5] = 5;\n    world[1][3] = 5;\n    world[1][4] = 5;\n  } else if (ran === 5 && world[0][5] === 0 && world[1][4] === 0 && world[1][5] === 0 && world[1][6] === 0) {\n    //Pyramid shape\n    world[0][5] = 6;\n    world[1][4] = 6;\n    world[1][5] = 6;\n    world[1][6] = 6;\n  } else if (ran === 6 && world[0][4] === 0 && world[1][4] === 0 && world[2][4] === 0 && world[2][3] === 0) {\n    //reverseLshape\n    world[0][4] = 7;\n    world[1][4] = 7;\n    world[2][4] = 7;\n    world[2][3] = 7;\n  } else {\n    if (score >= localStorage.getItem('best-score')) {\n      alert(\"Congrats ! This is your new best score: \" + score);\n    } else if (score < localStorage.getItem('best-score')) {\n      alert(\"Too bad! Try again!\");\n    }\n  }\n}\n\nfunction checkLines() {\n  var nbFullLine = 0;\n\n  for (var y = world.length - 1; y >= 0; y--) {\n    var fullLine = true;\n\n    for (var x = 0; x < world[y].length; x++) {\n      if (world[y][x] < 10) {\n        fullLine = false;\n      }\n    }\n\n    if (fullLine) {\n      world.splice(y, 1);\n      world.splice(0, 0, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]); //nbFullLine keeps track of the number of line destroyed at the same time to determine the appropriate score\n\n      nbFullLine++; //line_count allows to track number of line remaining before next level\n\n      line_count++; //lines keeps track of the number of lines destroyed\n\n      lines++;\n      document.getElementById('lines').innerHTML = lines;\n    }\n  }\n\n  if (nbFullLine === 1) {\n    score = score + 40 * (level + 1);\n    document.getElementById('score').innerHTML = score;\n  } else if (nbFullLine === 2) {\n    score = score + 100 * (level + 1);\n    document.getElementById('score').innerHTML = score;\n  } else if (nbFullLine === 2) {\n    score = score + 100 * (level + 1);\n    document.getElementById('score').innerHTML = score;\n  } else if (nbFullLine === 3) {\n    score = score + 300 * (level + 1);\n    document.getElementById('score').innerHTML = score;\n  } else if (nbFullLine === 4) {\n    score = score + 1200 * (level + 1);\n    document.getElementById('score').innerHTML = score;\n  }\n\n  if (score > localStorage.getItem('best-score')) {\n    localStorage.setItem('best-score', score);\n  }\n\n  document.getElementById('best').innerHTML = localStorage.getItem('best-score');\n}\n\nfunction levelup() {\n  if (line_count != 0 && line_count >= 5 * level) {\n    level++;\n    document.getElementById('level').innerHTML = level;\n    line_count = 0;\n\n    if (game_speed <= 250 && game_speed >= 50) {\n      game_speed = game_speed - 20;\n    } else if (game_speed <= 50) {//no change of speed\n    } else {\n      game_speed = game_speed - 150;\n    }\n  }\n}\n\ndocument.onkeydown = function (e) {\n  if (e.keyCode === 37) {\n    moveShapesLeft();\n  } else if (e.keyCode === 39) {\n    moveShapesRight();\n  } else if (e.keyCode === 40) {\n    moveShapesDown();\n  } else if (e.keyCode === 38) {\n    rotateShapeRight();\n\n    if (count === 3) {\n      count = 0;\n    }\n\n    ;\n    count++;\n  }\n};\n\nfunction gameLoop() {\n  moveShapesDown();\n  drawWorld();\n  levelup();\n  setTimeout(gameLoop, game_speed);\n}\n\nfunction ruinsLoop() {\n  var raandom = Math.floor(Math.random() * 6);\n\n  if (raandom === 0) {\n    //bar shape\n    ruins = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]];\n  } else if (raandom === 1) {\n    //L shape\n    ruins = [[0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 0, 0, 0, 0, 0], [0, 0, 0, 0, 2, 2, 0, 0, 0, 0]];\n  } else if (raandom === 2) {\n    //Z shape\n    ruins = [[0, 0, 0, 3, 3, 0, 0, 0, 0, 0], [0, 0, 0, 0, 3, 3, 0, 0, 0, 0]];\n  } else if (raandom === 3) {\n    //cube\n    ruins = [[0, 0, 0, 0, 4, 4, 0, 0, 0, 0], [0, 0, 0, 0, 4, 4, 0, 0, 0, 0]];\n  } else if (raandom === 4) {\n    //S shape\n    ruins = [[0, 0, 0, 0, 5, 5, 0, 0, 0, 0], [0, 0, 0, 5, 5, 0, 0, 0, 0, 0]];\n  } else if (raandom === 5) {\n    //Pyramid shape\n    ruins = [[0, 0, 0, 0, 6, 0, 0, 0, 0, 0], [0, 0, 0, 6, 6, 6, 0, 0, 0, 0]];\n  } else if (raandom === 6) {\n    //reverseLshape\n    ruins = [[0, 0, 0, 0, 7, 0, 0, 0, 0], [0, 0, 0, 0, 7, 0, 0, 0, 0], [0, 0, 0, 7, 7, 0, 0, 0, 0]];\n  }\n\n  drawRuins();\n  setTimeout(ruinsLoop, 9000);\n} //initial level, lines and game speed\n\n\nvar level = 0;\nvar lines = 0;\nvar score = 0;\nvar game_speed = 1000; //line_count keeps the count to know how many lines must be destroyed before next level.The variable is reset at each levelup.\n\nvar line_count = 0; //The variable 'count' is used for rotation of bar shape\n\nvar count = 0;\n\nif (localStorage.getItem('best-score') !== null) {\n  document.getElementById('best').innerHTML = localStorage.getItem('best-score');\n} else {\n  document.getElementById('best').innerHTML = \"0\";\n}\n\ndocument.getElementById('lines').innerHTML = \"0\";\ndocument.getElementById('level').innerHTML = \"0\";\ndocument.getElementById('score').innerHTML = \"0\";\ndrawWorld();\ndrawRuins();\ngameLoop();\nruinsLoop();\n\n//# sourceURL=webpack://babel_weback_starter/./src/tetris_script.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/tetris_script.js");
/******/ 	
/******/ })()
;